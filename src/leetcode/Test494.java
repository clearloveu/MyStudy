package leetcode;

/**
 * @author zg
 * @create 2020-02-13 16:43
 *
 * 目标和[中等]
 *
 * 给定一个非负整数数组，a1, a2, ..., an, 和一个目标数，S。现在你有两个符号 + 和 -。对于数组中的任意一个整数，你都可以从 + 或 -中选择一个符号添加在前面。
 *
 * 返回可以使最终数组和为目标数 S 的所有添加符号的方法数。
 *
 * 示例 1:
 * 输入: nums: [1, 1, 1, 1, 1], S: 3
 * 输出: 5
 * 解释:
 * -1+1+1+1+1 = 3
 * +1-1+1+1+1 = 3
 * +1+1-1+1+1 = 3
 * +1+1+1-1+1 = 3
 * +1+1+1+1-1 = 3
 * 一共有5种方法让最终目标和为3。
 *
 * 注意:
 * 	数组非空，且长度不会超过20。
 * 	初始的数组的和不会超过1000。
 * 	保证返回的最终结果能被32位整数存下。
 *
 */
public class Test494 {


    //我只想到暴力法：我们可以使用递归，枚举出所有可能的情况。具体地，当我们处理到第 i 个数时，我们可以将它添加 + 或 -，递归
    // 地搜索这两种情况。当我们处理完所有的 N 个数时，我们计算出所有数的和，并判断是否等于 S。

    //法二：转化为0/1背包问题
    //https://leetcode-cn.com/problems/target-sum/solution/dong-tai-gui-hua-ji-bai-liao-98de-javayong-hu-by-r/

    //法三：动态规划
    //我们用**dp[i][j] 表示用数组中的前 i 个元素，组成和为 j 的方案数**。考虑第 i 个数 nums[i]，它可以被添加 + 或 -，因此状态转移方程如下：
    // dp[i][j] = dp[i - 1][j - nums[i]] + dp[i - 1][j + nums[i]]
    //链接：https://leetcode-cn.com/problems/target-sum/solution/mu-biao-he-by-leetcode/
}
